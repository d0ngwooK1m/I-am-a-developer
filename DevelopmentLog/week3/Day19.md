# 항해 19일차

## 오늘 할 일  
2주차 강의 및 과제 완료 + @

## 리액트2 2주차 1강(2주차 오늘 배울 것)  

## 리액트2 2주차 2강(Promise)  
자바스크립트 => 싱글 쓰레드 언어  
작업을 한번에 한 개만 할 수 있다.  
근데 어떻게 동시에 작업이 가능하지?  

![자바스크립트구조](/images/react2_week2/1.PNG)  

기본적으로 자바스크립트 엔진은 메모리 힙과 콜스택으로 이루어진다. 콜 스택에 작업을 쌓아놓고 하나씩 처리하는 방식이다.  
여기에 Web API, (Ajax, setTimeOut, DOM), 콜백 큐, 이벤트 루프의 도움을 받아 여러개 작업이 동시에 가능하게 한다.  
1. 콜스택에서 setTimeOut에게 이벤트 위임(콜백 함수) 
2. setTimeOut의 시간이 끝나면 콜백 큐에 콜백 함수를 넣는다.
3. 이벤트 루프를 통해 콜백큐에서 콜스택으로 콜백 함수를 다시 넣는다.  

비동기 작업을 여러 개 한다고 생각했을 때 콜백 함수가 물리고 물리는 경우가 생긴다. 이런 중첩을 콜백 헬이라고 한다.  

이를 해결하기위해 Promise가 탄생했다.(⭐) Promise는 비동기 연산이 종료된 이후 결과를 알기 위해 사용하는 객체이다. 비동기 처리 시점을 좀 더 명확히 표현할 수 있다.  

```javascript
const promise = new Promise((resolve, reject) => {
    if(...) {
        resolve("성공");
    }
    else(...) {
        reject("실패");
    }
})
```

프로미스의 상태값
* pending: 비동기처리 수행 전(resolve, reject가 아직 호출되지 않음)
* fulfilled: 수행 성공(resolve가 호출된 상태)
* rejected: 수행 실패(reject가 호출된 상태)
* settled: 성공 또는 실패(resolve나 reject가 호출된 상태)  

프로미스 후속 처리 메서드
.then(처음 then은 성공 시, 두번째 then은 실패 시 사용, 성공 시 then만 사용해도 ㅇㅋ)
```javascript
let promise = new Promise((resolve, reject) => {
    setTimeout(() => {resolve("완료")}, 1000);
});

promise.then(result => {
    console.log(result);
}, error => {
    console.log("error");
});
//(실행하자마자) Promise(<pending>)
//(1초 뒤) 완료!
//(완료 메세지 뜬 이후 실행) Promise(<fulfilled>: "완료!")
```

프로미스 체이닝  
then을 여러 개 사용해서 프로미스를 연결  
프로미스 객체를 만들고 then을 사용해 하나씩 해결되게 연결  

async await  
* async: 항상 프로미스를 리턴해준다.
* await: 해당 프로미스 작업이 끝날 때 까지 기다렸다가 결과를 반환한다.  

기존 비동기 작업방식은 이벤트를 위임하고 다른일을 하는 방식이었는데, async await은 이벤트를 위임하고 그 일을 완료할 때 까지 다른 작업을 하지 않는다는 차이점이 있다.  

![Promise와 async,await의 차이 함수](/images/react2_week2/2.PNG)  
![Promise와 async,await의 차이 결과](/images/react2_week2/3.PNG)  

결과는 await를 붙이면 fulfilled가 된 상태에서 결과가 나온다.  

## 리액트2 2주차 3강(토큰 기반 인증)  
세션 기반 인증: 세션에 사용자의 로그인 상태를 서버가 전부 가지고 있는 형태 => 사용자가 많아지면 서버에 부하가 많이 온다. => 토큰 기반 인증 방법으로 발전  

OAuth2.0: access_token 발급으로 권한여부 확인 + 플랫폼 간의 권한 공유 가능 => 소셜 로그인 서비스 활용 가능  

![OAuth2.0 작동방식과 Refresh_Token](/images/react2_week2/4.PNG)  

구글과 내 서비스가 연동한다고 했을 때 작동방식  

JWT: 보안기능이 강화된 토큰 header, payload, signature가 암호화 되어 들어간다.  

두 방식을 상황에 맞게 잘 사용하면 된다!

## 리액트2 2주차 4강(웹 저장소(feat. 토큰))  
토큰을 어디에 가지고 있어야 하는가?  
웹 저장소(후보)
* 클라이언트 저장소
    개발자 도구(Application 탭)에서 확인가능

* 쿠키  
![쿠키 만드는 법](/images/react2_week2/5.PNG)  

    만료일이 지나면 파기된다.

* 세션 스토리지
    창을 닫으면 없어진다.

* 로컬 스토리지
    따로 지워주지 않으면 계속 유지된다.
    민감한 정보는 이 곳에 넣으면 절대 안됨!!  

결론: 상황에 맞게 사용하자!

## 리액트2 2주차 5강(웹 저장소(Quiz_누르면 쿠키를 저장하는 버튼))  

useRef가 아니라 useState!!! useState 쓰는 습관을 들이자!!  

useState로 [값1, 값2] 값2를 Input onChange에 두어 값1을 다시 바꾸게 한다. 태그에 onChange를 생각을 못했다. 꼭 기억해두자!  

## 리액트2 2주차 6강(로그인하기(1)-헤더 분기하고 리덕스 설치)
로그인 상태에 따라 버튼 다르게 리턴되게 설정

## 리액트2 2주차 7강(로그인하기(2)-유저 모듈 만들기)
리덕스 히스토리를 위한 redux-action과 불변성을 위한 immer 패키지, 쿠키들을 불러서 user.js 모듈 작성(작성법 많이 달라짐 숙달할 것)

## 리액트2 2주차 8강(로그인하기(3)-리덕스 스토어 만들기)
스토어 설정 모듈 불러오고 청크에서 라우터 히스토리 넣어서 넘겨줌

## 리액트2 2주차 9강(로그인하기(4)-스토어 주입하기)  
리덕스 업그레이드(action, immer) 이용해서 userdata관리  
코드를 짜는 방법 보다는 흐름, 순서 익히는 것이 더 중요하다!!

## 리액트2 2주차 10강(Firebase Authentication)  

## 리액트2 2주차 11강(회원가입 구현)  

## 리액트2 2주차 12강(로그인 구현)  

## 일기  
쌀 파는 개발자 김병욱님 특강  
포트폴리오: 나만의 스토리가 있는 포트폴리오를 만들어라! (왜 시작 => 어떤 노력)  
퍼밋은 실무에서 많이 쓰이지만 잘 쓰기 어려운 테크닉! 잘 쓰려고 노력해보자  
이메일 정규식 체크하는 방법 다시 확인!
